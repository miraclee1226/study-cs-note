## 디자인 패턴

프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계 등을 이용하여 해결할 수 있도록 하나의 ‘규약’ 형태로 만들어 놓은 것

### 1. 싱글톤 패턴

하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴
하나의 인스턴스를 만들어 놓고 해당 인스턴스를 다른 모듈들이 공유하며 사용
보통 데이터베이스 연결 모듈에 많이 사용

##### 싱글톤 패턴의 단점

싱글톤 패턴은 미리 생성된 하나의 인스턴스를 기반으로 구현하는 패턴이므로 테스트마다 ‘독립적인’ 인스턴스를 만들기 어려움
이를 해결하기 위해 **‘의존성 주입’** 을 통해 모듈간의 결합을 조금 더 느슨하게 만들어 해결할 수 있음

**의존성 주입이란?**

💁 DI(Dependency Injection)
의존성 주입자(dependency injector)가 중간에서 의존성을 주는 부분을 가로채 메인 모듈이 ‘간접’적으로 의존성을 주입하는 방식

- 의존성 주입의 장점
  - 모듈들을 쉽게 교체할 수 있는 구조로 테스팅과 마이그레이션이 용이함
  - 애플리케이션 의존성 방향이 일관되고 쉽게 추론할 수 있음
  - 모듈 간의 관계들이 더 명확해짐
- 의존성 주입의 단점
  - 클래스 수가 늘어나 복잡성 증가
  - 약간의 런타임 페널티 발생

### 2. 팩토리 패턴

객체 생성 부분을 분리하여 추상화한 패턴

상위 클래스가 중요한 뼈대를 결정, 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정

상위, 하위 클래스로 나뉘어져 느슨한 결합을 가지며 객체 생성 로직이 분리되어 리팩토링이 용이함

상위 클래스 - 바리스타 공장

하위 클래스 - 라떼 레시피, 아메리카노 레시피, 우유 레시피

### 3. 전략 패턴

객체의 행위를 ‘직접’ 수정하지 않고 ‘캡슐화한 알고리즘-전략’을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하게 만드는 패턴

### 4. 옵저버 패턴

주체가 어떤 객체의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 패턴

주체 - 객체의 상태 변화를 보고 있는 관찰자

옵저버 - 객체의 상태 변화에 따라 전달되는 메서드 등을 기반으로 ‘추가 변화 사항’이 생기는 객체들을 의미

**프록시 객체를 이용한 옵저버 패턴**

프록시 객체

어떠한 대상의 기본적인 동작의 작업을 가로챌 수 있는 객체

```jsx
function createReactiveObject(target, callback) {
  const proxy = new Proxy(target, {
    set(obj, prop, value) {
      if (value !== obj[prop]) {
        const prev = obj[prop];
        obj[prop] = value;
        callback(`${prop}가 [${prev}] >> [${value}] 로 변경되었습니다`);
      }
      return true;
    },
  });
  return proxy;
}
const a = {
  형규: "솔로",
};
const b = createReactiveObject(a, console.log);
b.형규 = "솔로";
b.형규 = "커플";
// 형규가 [솔로] >> [커플] 로 변경되었습니다
```

get() 함수 : 속성과 함수에 대한 접근을 가로챔

has() 함수 : in 연산자의 사용 가로챔

set() 함수 : 속성에 대한 접근을 가로채서 변화를 감시함

### 5. 프록시 패턴과 프록시 서버

대상 객체에 접근하기 전 그 접근에 대한 흐름을 가로채 접근을 필터링하거나 수정하는 등의 역할을 하는 계층이 있는 패턴

**프록시 서버**

서버와 클라이언트 사이에서 클라이언트가 자신을 통해 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템 또는 응용 프로그램

DDOS 공격 방어, HTTPS 구축으로 활용 가능

### 6. 이터레이터 패턴

이터레이터를 사용하여 컬렉션의 요소들에 접근하는 디자인 패턴

순회할 수 있는 여러 자료형의 구조와 상관없이 이터레이터라는 하나의 인터페이스로 순회 가능

### 7. 노출모듈 패턴

즉시 실행 함수를 통해 private, public 같은 접근 제어자를 만드는 패턴

자바스크립트의 경우 접근 제어자가 존재하지 않고 전역 범위에서 스크립트가 실행되므로 노출모듈 패턴을 통해 접근 제어자를 구현할 수 있음

### 8. MVC 패턴

모델(Model), 뷰(View), 컨트롤러(Controller)로 이루어진 디자인 패턴

- 모델 - 애플리케이션의 데이터(데이터베이스, 상수, 변수 등)
- 뷰 - 사용자 인터페이스 요소. 모델을 기반으로 사용자가 볼 수 있는 화면(데이터를 제외한)
- 컨트롤러 - 하나 이상의 모델과 하나 이상의 뷰를 잇는 다리 역할. 메인 로직을 담당

### 9. MVP 패턴

MVC에서 컨트롤러 대신 프레젠터(presenter)로 교체된 패턴

뷰와 프레젠터는 일대일 관계. MVC 패턴보다 더 강한 결합을 가짐

### 10. MVVM 패턴

MVC에서 컨트롤러 대신 뷰모델(view model)로 교체된 패턴

커맨드와 데이터 바인딩을 가지고 있음. 뷰와 뷰모델 사이의 양방향 데이터 바인딩을 지원하며 UI를 별도의 코드 수정 없이 재사용할 수 있음
